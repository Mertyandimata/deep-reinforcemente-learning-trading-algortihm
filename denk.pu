Elimde bir deep learning reinformecaaement ile stock alimi satimi yaapan bir kod mevcut, senden istedigim sey kodumu incelemen ve olasi iyilestirilecek fonskiyonlari belirlemen , hataya sebeb verecek veya kotu hesap yapabilecek yerleri bana anlatman , ayni zamanda suan printte sinyal tablosunda tum signaller notr yaziyor , signallerin dagitimi iyi egil ve hata var , burayi cok iyi yapmamiz lazim hatasiz bir baglanti olmali , her class ayri bir py sayfasi , simdi sana bir kac tanesini vereecegim ve bunlari cok detayli incelemeni istiyorum, ve sorunlari coz ve iyilestirmeleri yapalim import numpy as np
import pandas as pd
from signal_generator import SignalGenerator
from tabulate import tabulate
import logging
from colorama import Fore, Back, Style, init

init(autoreset=True)  # colorama iÃ§in otomatik sÄ±fÄ±rlama

class StockTradingEnv:
    def __init__(self, data, initial_balance=10000):
        self.data = data
        self.initial_balance = initial_balance
        self.signal_generator = SignalGenerator(data)
        self.reset()
        
        # Logging ayarlarÄ±
        logging.basicConfig(filename='trading_log.txt', level=logging.INFO, 
                            format='%(asctime)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

        # Action space'i geniÅŸlet
        self.action_space = 11  # 0: Sat, 1-5: FarklÄ± miktarlarda al, 6: Tut

    def reset(self):
        self.balance = self.initial_balance
        self.position = 0
        self.current_step = 0
        self.total_profit = 0
        self.entry_price = 0
        self.stop_loss = 0
        self.take_profit = 0
        self.highest_price = 0
        self.decline_counter = 0  # Gecikme sayacÄ± baÅŸlatÄ±lÄ±yor
        self.trades = []
        self.total_trail_gain = 0
        self.total_trail_loss = 0
        return self._next_observation()


    def _next_observation(self):
        signals = self.signal_generator.get_signals(self.current_step)
        
        # Extract only the 'value' from the signals
        signal_values = [data['value'] for data in signals.values()]
        
        obs = np.array([
            self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step],
            self.data['USDTRY'].iloc[self.current_step],
            self.data['BIST 100'].iloc[self.current_step],
            self.data['PiyasaDeÄŸeri(mn TL)'].iloc[self.current_step],
            self.balance,
            self.position,
            self.total_profit,
            self.entry_price,
            self.stop_loss,
            self.take_profit,
            (self.stop_loss - self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step]) / self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step],
            (self.take_profit - self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step]) / self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step],
        ] + signal_values + [sum(signal_values)])  # Now signal_values is a list of floats, so sum works

        return obs


    def step(self, action):
        prev_value = self.balance + self.position * self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step]
        
        self._take_action(action)
        self.current_step += 1
        done = self.current_step >= len(self.data) - 1
        
        obs = self._next_observation()

        # Burada toplam sinyali hesaplayÄ±p alÄ±yoruz
        total_signal = self.signal_generator.get_total_signal(self.current_step)

        current_value = self.balance + self.position * self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step]
        reward = self._calculate_reward(prev_value, current_value)
        self.total_profit += current_value - prev_value
        
        info = {
            'step': self.current_step,
            'balance': current_value,
            'profit': self.total_profit,
            'reward': reward,
            'position': self.position,
            'action': action,
            'price': self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step],
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'total_trail_gain': self.total_trail_gain,
            'total_trail_loss': self.total_trail_loss,
            'total_signal': total_signal  # Yeni eklenen satÄ±r
        }

        self._print_step_info(info)
        self._log_step_info(info)

        return obs, reward, done, info


    # Gecikmeli pozisyon kapatma
    def _take_action(self, action):
        current_price = self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step]
        
        # Sinyal doÄŸrulama
        signals = self.signal_generator.get_signals(self.current_step)
        positive_signals = sum(1 for data in signals.values() if data['value'] > 0)
        negative_signals = sum(1 for data in signals.values() if data['value'] < 0)
        
        total_signal = self.signal_generator.get_total_signal(self.current_step)
        
        # AlÄ±m iÅŸlemi
        if positive_signals >= 3 and action in [1, 2, 3] and total_signal > 0:
            if self.position == 0:
                self._open_position(current_price)
        
        # Gecikmeli satÄ±ÅŸ iÅŸlemi: Pozisyon kapanmadan Ã¶nce 2 bar bekleme
        elif negative_signals >= 3 and action == 0 and total_signal < 0:
            if self.position > 0 and self.current_step - self.decline_counter >= 2:
                self._close_position(current_price)
            else:
                self.decline_counter += 1  # Gecikme iÃ§in adÄ±m sayacÄ±




    def _open_position(self, price, buy_percentage=1.0):
        max_shares = int((self.balance * buy_percentage) // price)
        risk_percentage = self._calculate_dynamic_risk()
        buy_amount = self._calculate_buy_amount()
        shares_to_buy = max(1, int(max_shares * min(risk_percentage, buy_amount)))
        cost = shares_to_buy * price
        if cost <= self.balance:
            self.position += shares_to_buy
            self.balance -= cost
            self.entry_price = price
            self.highest_price = price
            self.decline_counter = 0
            
            self._set_dynamic_stop_loss_take_profit(price)
            
            self.trades.append({'type': 'buy', 'price': price, 'shares': shares_to_buy, 'step': self.current_step})
            
            print(f"\n{Fore.GREEN}ğŸ›’ ALIÅ Ä°ÅLEMÄ° GERÃ‡EKLEÅTI{Style.RESET_ALL}")
            print(tabulate([
                ["AlÄ±nan Hisse Adedi", f"{shares_to_buy:,}"],
                ["AlÄ±ÅŸ FiyatÄ±", f"{price:,.2f} TL"],
                ["Toplam Maliyet", f"{cost:,.2f} TL"],
                ["Yeni Nakit Bakiye", f"{self.balance:,.2f} TL"],
                ["Stop-Loss", f"{self.stop_loss:,.2f} TL"],
                ["Take-Profit", f"{self.take_profit:,.2f} TL"]
            ], tablefmt="fancy_grid"))

    def _close_position(self, price):
        sell_value = self.position * price
        profit = sell_value - (self.position * self.entry_price)
        self.balance += sell_value
        
        if price >= self.take_profit:
            self.total_trail_gain += (price - self.entry_price) * self.position
        elif price <= self.stop_loss:
            self.total_trail_loss += (self.entry_price - price) * self.position

        self.trades.append({'type': 'sell', 'price': price, 'shares': self.position, 'step': self.current_step})

        print(f"\n{Fore.RED}ğŸ’° SATIÅ Ä°ÅLEMÄ° GERÃ‡EKLEÅTI{Style.RESET_ALL}")
        print(tabulate([
            ["SatÄ±lan Hisse Adedi", f"{self.position:,}"],
            ["SatÄ±ÅŸ FiyatÄ±", f"{price:,.2f} TL"],
            ["Toplam DeÄŸer", f"{sell_value:,.2f} TL"],
            ["KÃ¢r/Zarar", f"{profit:,.2f} TL"],
            ["Yeni Nakit Bakiye", f"{self.balance:,.2f} TL"]
        ], tablefmt="fancy_grid"))
        
        self.position = 0
        self.entry_price = 0
        self.stop_loss = 0
        self.highest_price = 0

    def _calculate_reward(self, prev_value, current_value):
        if prev_value == 0:
            return 0
        
        # Temel Ã¶dÃ¼l: PortfÃ¶y deÄŸerindeki deÄŸiÅŸim
        base_reward = (current_value - prev_value) / prev_value * 100
        
        # Piyasa koÅŸullarÄ±na gÃ¶re Ã¶dÃ¼l ayarlamasÄ±
        market_trend = self._calculate_market_trend()
        if (market_trend > 0 and base_reward > 0) or (market_trend < 0 and base_reward < 0):
            base_reward *= 2.2  # Trend ile uyumlu hareket ettiÄŸinde bonus
        else:
            base_reward *= 0.8  # Trende karÅŸÄ± hareket ettiÄŸinde ceza
        
        # Risk yÃ¶netimi Ã¶dÃ¼lÃ¼
        risk_reward = self._calculate_risk_reward()
        
        # Uzun vadeli performans Ã¶dÃ¼lÃ¼
        long_term_reward = self._calculate_long_term_reward()
        
        # Teknik gÃ¶sterge uyumu Ã¶dÃ¼lÃ¼
        technical_reward = self._calculate_technical_indicator_reward()
        
        # Toplam Ã¶dÃ¼l hesaplama
        total_reward = base_reward + risk_reward + long_term_reward + technical_reward
        
        # Ã–dÃ¼l bileÅŸenlerini yazdÄ±rma
        print(f"\nğŸ’¹ Temel Ã–dÃ¼l: {base_reward:.2f}")
        print(f"ğŸ›¡ï¸ Risk YÃ¶netimi Ã–dÃ¼lÃ¼: {risk_reward:.2f}")
        print(f"ğŸ“ˆ Uzun Vadeli Performans Ã–dÃ¼lÃ¼: {long_term_reward:.2f}")
        print(f"ğŸ“Š Teknik GÃ¶sterge Uyumu Ã–dÃ¼lÃ¼: {technical_reward:.2f}")
        print(f"ğŸ† Toplam Ã–dÃ¼l: {total_reward:.2f}")
        
        if total_reward > 0:
            print(f"{Fore.GREEN}âœ… Robot etkili bir karar aldÄ±!{Style.RESET_ALL}")
        elif total_reward < 0:
            print(f"{Fore.RED}âŒ Robot iyileÅŸtirme gerektiren bir karar aldÄ±.{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}â– Robot nÃ¶tr bir karar aldÄ±.{Style.RESET_ALL}")
        
        return total_reward
    
    def _calculate_risk_reward(self):
        if self.position == 0:
            return 0
        
        current_price = self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step]
        risk = abs(self.entry_price - self.stop_loss)
        reward = abs(self.take_profit - self.entry_price)
        
        if risk == 0:
            return 0
        
        risk_reward_ratio = reward / risk
        
        if current_price >= self.take_profit:
            return 10 * risk_reward_ratio  # Take-profit'e ulaÅŸÄ±ldÄ±ÄŸÄ±nda bÃ¼yÃ¼k Ã¶dÃ¼l
        elif current_price <= self.stop_loss:
            return -5 * (1 / risk_reward_ratio)  # Stop-loss'a ulaÅŸÄ±ldÄ±ÄŸÄ±nda bÃ¼yÃ¼k ceza
        else:
            return 2 * risk_reward_ratio  # Pozisyon devam ederken kÃ¼Ã§Ã¼k Ã¶dÃ¼l

    def _calculate_long_term_reward(self):
        if len(self.trades) < 10:
            return 0
        
        recent_trades = self.trades[-10:]
        profitable_trades = sum(1 for trade in recent_trades if trade['type'] == 'sell' and trade['price'] > trade['price'])
        return (profitable_trades / 10 - 0.5) * 10  # -5 ile 5 arasÄ±nda bir deÄŸer

    def _calculate_technical_indicator_reward(self):
        signals = self.signal_generator.get_signals(self.current_step)
        
        # Extract only the 'value' from the signal dictionaries for summing
        signal_values = [data['value'] for data in signals.values()]
        
        # Now sum the signal values
        total_signal = sum(signal_values)
        
        # Check the alignment of signals with the current position
        if (total_signal > 0 and self.position > 0) or (total_signal < 0 and self.position == 0):
            return 5  # Technical indicators aligned with the position
        elif (total_signal < 0 and self.position > 0) or (total_signal > 0 and self.position == 0):
            return -5  # Technical indicators not aligned with the position
        else:
            return 0  # Neutral case

        
    def _calculate_market_trend(self):
        # 50 ve 100 gÃ¼nlÃ¼k hareketli ortalamalarÄ± kullanarak trendi tespit et
        ma_50 = self.data['KapanÄ±ÅŸ(TL)'].rolling(window=20).mean().iloc[self.current_step]
        ma_100 = self.data['KapanÄ±ÅŸ(TL)'].rolling(window=50).mean().iloc[self.current_step]
        current_price = self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step]
        
        # Trend tespiti: fiyat, uzun vadeli ortalamanÄ±n Ã¼stÃ¼ndeyse yÃ¼kseliÅŸ, altÄ±ndaysa dÃ¼ÅŸÃ¼ÅŸ
        if current_price > ma_50 and ma_50 > ma_100:
            return 1  # YÃ¼kseliÅŸ trendi
        elif current_price < ma_50 and ma_50 < ma_100:
            return -1  # DÃ¼ÅŸÃ¼ÅŸ trendi
        else:
            return 0  # Yatay trend


    def _update_trailing_stop_and_profit(self, current_price):
        high = self.data['Max(TL)'].iloc[self.current_step]
        low = self.data['Min(TL)'].iloc[self.current_step]
        
        if self.current_step == 0:
            prev_close = self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step]
        else:
            prev_close = self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step - 1]
        
        true_range = max(high - low, abs(high - prev_close), abs(low - prev_close))
        atr = true_range

        atr_multiplier = 2
        new_stop_loss = current_price - (atr * atr_multiplier)

        if current_price > self.highest_price:
            self.highest_price = current_price
            self.stop_loss = max(self.stop_loss, new_stop_loss)
            print(f"\n{Fore.YELLOW}ğŸ“ˆ YENÄ° EN YÃœKSEK FÄ°YAT VE STOP-LOSS{Style.RESET_ALL}")
            print(tabulate([
                ["Yeni En YÃ¼ksek Fiyat", f"{current_price:,.2f} TL"],
                ["Yeni Stop-Loss", f"{self.stop_loss:,.2f} TL"]
            ], tablefmt="fancy_grid"))
        elif current_price < self.highest_price:
            print(f"\n{Fore.YELLOW}ğŸ“‰ FÄ°YAT DÃœÅÃœÅÃœ{Style.RESET_ALL}")
            print(tabulate([
                ["Mevcut Fiyat", f"{current_price:,.2f} TL"],
                ["Mevcut Stop-Loss", f"{self.stop_loss:,.2f} TL"]
            ], tablefmt="fancy_grid"))

    def _get_signal_status(self, signal_value):
        try:
            # Ã–ncelikle signal_value'nun sayÄ±sal bir deÄŸer olduÄŸundan emin olalÄ±m
            signal_value = float(signal_value)
        except ValueError:
            return f"âšª GeÃ§ersiz Sinyal ({signal_value})"  # EÄŸer sayÄ±sal bir deÄŸer deÄŸilse

        abs_value = abs(signal_value)
        
        if abs_value > 0.7:
            return f"ğŸŸ¢ GÃ¼Ã§lÃ¼ Al ({signal_value:.4f})" if signal_value > 0 else f"ğŸ”´ GÃ¼Ã§lÃ¼ Sat ({signal_value:.4f})"
        elif abs_value > 0.5:
            return f"ğŸŸ¡ Al ({signal_value:.4f})" if signal_value > 0 else f"ğŸŸ  Sat ({signal_value:.4f})"
        elif abs_value > 0.3:
            return f"ğŸŸ¡ ZayÄ±f Al ({signal_value:.4f})" if signal_value > 0 else f"ğŸŸ  ZayÄ±f Sat ({signal_value:.4f})"
        elif abs_value > 0.1:
            return f"âšª ZayÄ±f Al ({signal_value:.4f})" if signal_value > 0 else f"âšª ZayÄ±f Sat ({signal_value:.4f})"
        else:
            return f"âšª NÃ¶tr ({signal_value:.4f})"




    def _get_robot_decision(self, action):
        if action == 0:
            return "ğŸ”´ Sat"
        elif 1 <= action <= 3:
            return "ğŸŸ¡ Az Al"
        elif 4 <= action <= 7:
            return "ğŸŸ¢ Orta Al"
        elif 8 <= action <= 10:
            return "ğŸ”µ Ã‡ok Al"
        else:
            return "âšª Tut"


    def _print_step_info(self, info):
        action_emoji = {0: "ğŸ”´", 1: "ğŸŸ¡", 2: "ğŸŸ ", 3: "ğŸŸ¢", 4: "ğŸ”µ", 5: "ğŸŸ£", 6: "âšª", 7: "ğŸŸ¤", 8: "âš«", 9: "ğŸŸ¥", 10: "ğŸŸ©"}
        signal_status = self._get_signal_status(info['total_signal'])
        robot_decision = self._get_robot_decision(info['action'])
        
        print(f"\n{'='*100}")
        print(f"{Fore.CYAN}ğŸ“Š ADIM BÄ°LGÄ°LERÄ° - AdÄ±m {info['step']}{Style.RESET_ALL}")
        
        # AdÄ±m bilgileri tablosu
        step_table = tabulate([
            ["Mevcut Fiyat", f"{info['price']:,.2f} TL"],
            ["PortfÃ¶y DeÄŸeri", f"{info['balance']:,.2f} TL"],
            ["Nakit Bakiye", f"{self.balance:,.2f} TL"],
            ["Pozisyon", f"{info['position']:,} adet"],
            ["Toplam KÃ¢r/Zarar", f"{info['profit']:,.2f} TL"],
            ["Son Ä°ÅŸlem KÃ¢rÄ±", f"{(info['balance'] - (self.balance + info['position'] * info['price'])):,.2f} TL"],
            ["Stop-Loss", f"{info['stop_loss']:,.2f} TL"],
            ["Take-Profit", f"{info['take_profit']:,.2f} TL"],
            ["Takipten KazanÃ§", f"{info['total_trail_gain']:,.2f} TL"],
            ["Takipten KayÄ±p", f"{info['total_trail_loss']:,.2f} TL"],
            ["Aksiyon", f"{action_emoji[info['action']]} ({info['action']})"],
            ["Ã–dÃ¼l", f"{info['reward']:,.2f}"],
            ["Genel Sinyal", f"{signal_status}"],
            ["Robot KararÄ±", f"{robot_decision}"]
        ], tablefmt="fancy_grid")

        # Sinyal bilgileri tablosu
        signals = self.signal_generator.get_signals(self.current_step)
        signal_table = tabulate([
            [signal, f"{data['value']:.4f}", self._get_signal_status(data['value'])] for signal, data in signals.items()
        ], headers=["Sinyal", "DeÄŸer", "Durum"], tablefmt="fancy_grid")

        # Her iki tabloyu da aynÄ± geniÅŸlikte ve dÃ¼zgÃ¼n ÅŸekilde yazdÄ±rma
        step_lines = step_table.split('\n')
        signal_lines = signal_table.split('\n')
        
        # En uzun tabloya gÃ¶re satÄ±r sayÄ±sÄ±nÄ± eÅŸitleme
        max_lines = max(len(step_lines), len(signal_lines))
        step_lines += [' ' * len(step_lines[0])] * (max_lines - len(step_lines))
        signal_lines += [' ' * len(signal_lines[0])] * (max_lines - len(signal_lines))
        
        # SatÄ±rlarÄ± yan yana yazdÄ±rma
        for step_line, signal_line in zip(step_lines, signal_lines):
            print(f"{step_line}    {signal_line}")

        # Market trendini hesaplayÄ±p yazdÄ±rma
        market_trend = self._calculate_market_trend()
        if market_trend > 0.5:
            trend_desc = "ğŸ“ˆ Sert ArtÄ±yor"
        elif market_trend > 0:
            trend_desc = "ğŸ“ˆ ArtÄ±yor"
        elif market_trend < -0.5:
            trend_desc = "ğŸ“‰ Sert AzalÄ±yor"
        elif market_trend < 0:
            trend_desc = "ğŸ“‰ AzalÄ±yor"
        else:
            trend_desc = "â– NÃ¶tr"

        print(f"\n{Fore.MAGENTA}ğŸ“Š Market Trend: {trend_desc}{Style.RESET_ALL}")
        print(f"{'='*100}\n")


    def _log_step_info(self, info):
        log_message = (
            f"AdÄ±m: {info['step']} | "
            f"Fiyat: {info['price']:.2f} TL | "
            f"PortfÃ¶y: {info['balance']:.2f} TL | "
            f"Pozisyon: {info['position']} | "
            f"KÃ¢r/Zarar: {info['profit']:.2f} TL | "
            f"Stop-Loss: {info['stop_loss']:.2f} TL | "
            f"Take-Profit: {info['take_profit']:.2f} TL | "
            f"Aksiyon: {info['action']} | "
            f"Ã–dÃ¼l: {info['reward']:.2f}"
        )
        logging.info(log_message)

        # Sinyal aÄŸÄ±rlÄ±klarÄ±nÄ± da logla
        signals = self.signal_generator.get_signals(self.current_step)
        signal_table = tabulate([
            [signal, f"{data['value']:.4f}", data['status']] for signal, data in signals.items()
        ], headers=["Sinyal", "DeÄŸer", "Durum"], tablefmt="fancy_grid")
        
        for signal, data in signals.items():
            logging.info(f"Sinyal: {signal} | AÄŸÄ±rlÄ±k: {data['value']:.4f}")


    def _calculate_dynamic_risk(self):
        try:
            # total_signal'Ä± sayÄ±sal bir deÄŸere dÃ¶nÃ¼ÅŸtÃ¼r
            total_signal = float(self.signal_generator.get_total_signal(self.current_step))
        except ValueError:
            print("GeÃ§ersiz total_signal deÄŸeri. VarsayÄ±lan risk seviyesi kullanÄ±lacak.")
            return 0.2  # EÄŸer sayÄ±sal bir deÄŸer deÄŸilse, varsayÄ±lan bir risk seviyesi dÃ¶ndÃ¼rÃ¼lebilir.

        if total_signal > 0.5:
            return 0.45  # YÃ¼ksek risk
        elif total_signal < -0.5:
            return 0.1  # DÃ¼ÅŸÃ¼k risk
        else:
            return 0.2  # Orta risk


    def _is_in_downtrend(self):
        current_price = self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step]
        ma_50 = self.data['KapanÄ±ÅŸ(TL)'].rolling(window=50).mean().iloc[self.current_step]
        return current_price < ma_50
    
    def _calculate_buy_amount(self):
        # Son 10 gÃ¼nlÃ¼k fiyat deÄŸiÅŸimi
        price_change = self.data['KapanÄ±ÅŸ(TL)'].pct_change(periods=10).iloc[self.current_step]
        
        # 50 gÃ¼nlÃ¼k hareketli ortalama
        ma_50 = self.data['KapanÄ±ÅŸ(TL)'].rolling(window=50).mean().iloc[self.current_step]
        
        # Mevcut fiyat
        current_price = self.data['KapanÄ±ÅŸ(TL)'].iloc[self.current_step]
        
        # 20 gÃ¼nlÃ¼k volatilite
        volatility = self.data['KapanÄ±ÅŸ(TL)'].pct_change().rolling(window=20).std().iloc[self.current_step]
        
        # Piyasa trendi (1: yÃ¼kseliÅŸ, -1: dÃ¼ÅŸÃ¼ÅŸ, 0: yatay)
        trend = 1 if current_price > ma_50 else (-1 if current_price < ma_50 else 0)
        
        # Mevcut portfÃ¶y deÄŸeri
        portfolio_value = self.balance + (self.position * current_price)
        
        # Temel alÄ±m yÃ¼zdesi
        base_buy_percentage = 0.9  # YÃ¼ksek alÄ±m yÃ¼zdesi

        # Trend bazlÄ± ayarlama
        if trend == 1:
            base_buy_percentage *= 1.3  # YÃ¼kseliÅŸ trendinde daha fazla alÄ±m
        elif trend == -1:
            base_buy_percentage *= 0.9  # DÃ¼ÅŸÃ¼ÅŸ trendinde daha az alÄ±m

        # Fiyat deÄŸiÅŸimine gÃ¶re ayarlama
        if price_change < -0.05:
            base_buy_percentage *= 1.5  # BÃ¼yÃ¼k dÃ¼ÅŸÃ¼ÅŸlerde daha fazla alÄ±m
        elif price_change < -0.03:
            base_buy_percentage *= 1.2  # Orta dÃ¼ÅŸÃ¼ÅŸlerde daha fazla alÄ±m

        # Volatiliteye gÃ¶re ayarlama
        if volatility > 0.03:  # YÃ¼ksek volatilite
            base_buy_percentage *= 1.1  # Volatilite varsa daha fazla alÄ±m yap

        # Maksimum alÄ±m yÃ¼zdesini artÄ±r
        max_buy_percentage = 0.9  # Maksimum alÄ±m yÃ¼zdesini %90 yap
        buy_percentage = min(base_buy_percentage, max_buy_percentage)
        
        # Toplam portfÃ¶y deÄŸerinin en fazla %90'Ä±nÄ± riske at
        max_risk_amount = portfolio_value * 0.9  # Maksimum risk oranÄ±nÄ± artÄ±r
        buy_amount = min(self.balance * buy_percentage, max_risk_amount)

        # Minimum 5000 TL'lik alÄ±m yapÄ±lmasÄ±nÄ± garanti etmek iÃ§in bir minimum deÄŸer belirle
        min_alim_miktari = 5000  # En az 5000 TL'lik alÄ±m yapÄ±lmasÄ±nÄ± saÄŸla
        buy_amount = max(buy_amount, min_alim_miktari)
        
        return buy_amount / self.balance  # Oran olarak dÃ¶ndÃ¼r





    def _set_dynamic_stop_loss_take_profit(self, price):
        # ATR'yi hesaplayalÄ±m ve volatiliteyi belirleyelim
        atr_value = self._calculate_atr()
        volatility = self.data['KapanÄ±ÅŸ(TL)'].pct_change().rolling(window=20).std().iloc[self.current_step]
        
        # Volatiliteye gÃ¶re stop-loss ve take-profit seviyelerini belirleyelim
        if volatility > 0.03:  # YÃ¼ksek volatilite
            self.stop_loss = price - (4 * atr_value)  # ATR bazlÄ± dinamik stop-loss
            self.take_profit = price + (5 * atr_value)
        else:  # DÃ¼ÅŸÃ¼k volatilite
            self.stop_loss = price - (3 * atr_value)
            self.take_profit = price + (4 * atr_value)
        
        # FiyatÄ± izleyerek dinamik stop-loss ve kÃ¢r kilitleme mekanizmasÄ±
        if price > self.highest_price:
            self.highest_price = price
            print(f"\n{Fore.GREEN}ğŸ“ˆ Yeni En YÃ¼ksek Fiyat: {price:,.2f} TL. Stop-loss gÃ¼ncellendi.{Style.RESET_ALL}")
        
        # KÃ¢rÄ± korumak iÃ§in kademeli satÄ±ÅŸ mekanizmasÄ±
        if price <= self.highest_price * 0.95 and self.position > 0:
            print(f"\n{Fore.RED}âš ï¸ Fiyat en yÃ¼ksek seviyeden %5 dÃ¼ÅŸtÃ¼. Pozisyonun %50'sini satÄ±yoruz.{Style.RESET_ALL}")
            self._close_partial_position(price, sell_percentage=0.5)
        
        if price <= self.highest_price * 0.90 and self.position > 0:
            print(f"\n{Fore.RED}âš ï¸ Fiyat en yÃ¼ksek seviyeden %10 dÃ¼ÅŸtÃ¼. Kalan tÃ¼m pozisyonu kapatÄ±yoruz.{Style.RESET_ALL}")
            self._close_position(price)
        
        # Stop-loss ve take-profit seviyelerini gÃ¶sterelim
        print(f"\n{Fore.YELLOW}ğŸ“Š GÃ¼ncel Stop-Loss ve Take-Profit Seviyeleri{Style.RESET_ALL}")
        print(tabulate([
            ["En YÃ¼ksek Fiyat", f"{self.highest_price:,.2f} TL"],
            ["Yeni Stop-Loss", f"{self.stop_loss:,.2f} TL"],
            ["Yeni Take-Profit", f"{self.take_profit:,.2f} TL"]
        ], tablefmt="fancy_grid"))


    def _close_partial_position(self, price, sell_percentage=0.5):
        shares_to_sell = int(self.position * sell_percentage)
        sell_value = shares_to_sell * price
        self.balance += sell_value
        self.position -= shares_to_sell
        
        profit = sell_value - (shares_to_sell * self.entry_price)
        
        print(f"\n{Fore.RED}ğŸ’° KISMÄ° SATIÅ GERÃ‡EKLEÅTÄ°{Style.RESET_ALL}")
        print(tabulate([
            ["SatÄ±lan Hisse Adedi", f"{shares_to_sell:,}"],
            ["SatÄ±ÅŸ FiyatÄ±", f"{price:,.2f} TL"],
            ["Toplam DeÄŸer", f"{sell_value:,.2f} TL"],
            ["KÃ¢r/Zarar", f"{profit:,.2f} TL"],
            ["Yeni Nakit Bakiye", f"{self.balance:,.2f} TL"]
        ], tablefmt="fancy_grid"))




    def _calculate_atr(self, window=14):
        high = self.data['Max(TL)']
        low = self.data['Min(TL)']
        close = self.data['KapanÄ±ÅŸ(TL)']
        
        tr1 = high - low
        tr2 = abs(high - close.shift())
        tr3 = abs(low - close.shift())
        
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr = tr.rolling(window=window).mean()
        
        return atr.iloc[self.current_step]

    def calculate_sharpe_ratio(self):
        if len(self.trades) < 2:
            return 0

        returns = [(t['price'] / t['price'] - 1) for t in self.trades if t['type'] == 'sell']
        if not returns:
            return 0

        return np.sqrt(252) * np.mean(returns) / np.std(returns)

    def calculate_max_drawdown(self):
        peak = self.initial_balance
        max_drawdown = 0

        for trade in self.trades:
            if trade['type'] == 'sell':
                current_value = trade['price'] * trade['shares']
                if current_value > peak:
                    peak = current_value
                drawdown = (peak - current_value) / peak
                max_drawdown = max(max_drawdown, drawdown)

        return max_drawdown

    def calculate_win_loss_ratio(self):
        wins = sum(1 for t in self.trades if t['type'] == 'sell' and t['price'] > t['price'])
        losses = sum(1 for t in self.trades if t['type'] == 'sell' and t['price'] <= t['price'])
        return wins / losses if losses > 0 else float('inf')

    def calculate_profit_factor(self):
        gross_profit = sum(t['price'] * t['shares'] - t['price'] * t['shares'] for t in self.trades if t['type'] == 'sell' and t['price'] > t['price'])
        gross_loss = sum(t['price'] * t['shares'] - t['price'] * t['shares'] for t in self.trades if t['type'] == 'sell' and t['price'] <= t['price'])
        return gross_profit / abs(gross_loss) if gross_loss != 0 else float('inf')

    def get_performance_metrics(self):
        return {
            "Sharpe Ratio": self.calculate_sharpe_ratio(),
            "Max Drawdown": self.calculate_max_drawdown(),
            "Win/Loss Ratio": self.calculate_win_loss_ratio(),
            "Profit Factor": self.calculate_profit_factor()
        }

    def print_performance_summary(self):
        metrics = self.get_performance_metrics()
        print(f"\n{Fore.CYAN}ğŸ“ˆ PERFORMANS Ã–ZETI{Style.RESET_ALL}")
        print(tabulate([(k, f"{v:.2f}") for k, v in metrics.items()], tablefmt="fancy_grid"))

    def get_state_size(self):
        return len(self._next_observation())

    def get_action_size(self):
        return self.action_space

# StockTradingEnv sÄ±nÄ±fÄ± burada sona eriyor,import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from ta.trend import EMAIndicator, MACD, IchimokuIndicator, PSARIndicator
from ta.momentum import RSIIndicator, StochasticOscillator
from ta.volatility import BollingerBands, AverageTrueRange
from ta.volume import OnBalanceVolumeIndicator
from collections import deque
from nbar_detector import NBARReversalDetector
from order_blocks import OrderBlockDetector


class SignalGenerator:
    def __init__(self, data):
        self.data = data
        self.signals = {}
        self.weights = {}
        self.usage_count = {}
        self.reward_history = {}
        self.reward_deque = {}
        self.performance_score = {}
        self.n_steps_for_reward_avg = 10  # AÄŸÄ±rlÄ±k gÃ¼ncellemelerinde ortalamayÄ± kullanma periyodu
        self.nbar_detector = NBARReversalDetector(data, use_volume=True, use_atr=True)
        self.ob_detector = OrderBlockDetector(data)
        self.ob_detector.detect_order_blocks()

        self.initialize_signals()
        self.initialize_weights()

    def initialize_signals(self):
        # TÃ¼m sinyallerin baÅŸlatÄ±lmasÄ±
        self.signals['Adaptive_SuperTrend'] = self.adaptive_supertrend()
        self.signals['EMA_5_10'] = self.ema_crossover(5, 10)
        self.signals['EMA_10_21'] = self.ema_crossover(10, 21)
        self.signals['MACD'] = self.macd_signal()
        self.signals['RSI'] = self.rsi_signal()
        self.signals['BB'] = self.bollinger_bands_signal()
        self.signals['PSAR'] = self.psar_signal()
        self.signals['NBAR'] = self.nbar_signal()
        self.signals['OrderBlocks'] = self.order_blocks_signal()
        self.signals['Ichimoku'] = self.ichimoku_signal()
        self.signals['Stochastic'] = self.stochastic_signal()
        self.signals['OBV'] = self.obv_signal()
        self.signals['Support_Resistance'] = self.support_resistance_signal()

    def initialize_weights(self):
        total_signals = len(self.signals)
        for signal in self.signals:
            if signal == 'Adaptive_SuperTrend':
                self.weights[signal] = 0.5  # Adaptive SuperTrend'in aÄŸÄ±rlÄ±ÄŸÄ±nÄ± her zaman 0.5 yap
            elif signal == 'OrderBlocks':
                self.weights[signal] = 0.1  # Order Blocks iÃ§in aÄŸÄ±rlÄ±ÄŸÄ± daha dÃ¼ÅŸÃ¼k yap
            else:
                self.weights[signal] = (1.0 - 0.5 - 0.1) / (total_signals - 2)  # DiÄŸer sinyallerin aÄŸÄ±rlÄ±ÄŸÄ±nÄ± dengeli daÄŸÄ±t
            self.usage_count[signal] = 0
            self.reward_history[signal] = []
            self.reward_deque[signal] = deque(maxlen=self.n_steps_for_reward_avg)
            self.performance_score[signal] = 0.5  # BaÅŸlangÄ±Ã§ performans skoru


    # DoÄŸrusal aÄŸÄ±rlÄ±klandÄ±rma
    def linear_weighting(self, performance_score):
        return performance_score  

    # Logaritmik aÄŸÄ±rlÄ±klandÄ±rma
    def logarithmic_weighting(self, performance_score):
        return np.log1p(performance_score)

    # Ãœssel aÄŸÄ±rlÄ±klandÄ±rma
    def exponential_weighting(self, performance_score):
        return np.exp(performance_score)

    def update_weights(self, rewards, method='linear'):
        """
        AÄŸÄ±rlÄ±klarÄ± performans skoruna gÃ¶re gÃ¼nceller.
        :param rewards: Her sinyalin aldÄ±ÄŸÄ± Ã¶dÃ¼ller.
        :param method: 'linear', 'logarithmic' ya da farklÄ± aÄŸÄ±rlÄ±klandÄ±rma metodlarÄ±.
        """
        # SeÃ§ilen metodun fonksiyonunu haritadan alalÄ±m
        method_map = {
            'linear': self.linear_weighting,
            'logarithmic': self.logarithmic_weighting,
            'exponential': self.exponential_weighting  # Ekstra metodlar buraya eklenebilir
        }

        if method not in method_map:
            raise ValueError(f"Invalid method. Available methods are: {list(method_map.keys())}")

        # SeÃ§ilen metodun fonksiyonunu Ã§ekiyoruz
        weighting_function = method_map[method]

        for signal, reward in rewards.items():
            if signal != 'Adaptive_SuperTrend':  # Adaptif SuperTrend sabit kalabilir
                self.reward_deque[signal].append(reward)
                avg_reward = np.mean(self.reward_deque[signal])

                # Performans skorunu gÃ¼ncelle
                self.performance_score[signal] = self.performance_score[signal] * 0.95 + (0.05 * (1 if avg_reward > 0 else 0))

                # SeÃ§ilen metodun fonksiyonunu kullanarak yeni aÄŸÄ±rlÄ±ÄŸÄ± hesapla
                new_weight = weighting_function(self.performance_score[signal])

                # Minimum aÄŸÄ±rlÄ±k sÄ±nÄ±rÄ± koy
                self.weights[signal] = max(0.01, new_weight)

        # Adaptive SuperTrend'in aÄŸÄ±rlÄ±ÄŸÄ±nÄ± sabit tut
        self.weights['Adaptive_SuperTrend'] = 0.5

        # NÃ¶tr sinyalleri (aÄŸÄ±rlÄ±k deÄŸeri 0'a yakÄ±n olanlarÄ±) ayÄ±kla ve diÄŸerlerini normalize et
        total_weight = sum(w for s, w in self.weights.items() if s != 'Adaptive_SuperTrend' and abs(w) > 0.05)

        # Toplam aÄŸÄ±rlÄ±ÄŸÄ±n 1 olmasÄ±nÄ± saÄŸlamak iÃ§in normalize et
        for signal in self.weights:
            if signal != 'Adaptive_SuperTrend' and abs(self.weights[signal]) > 0.05:
                self.weights[signal] /= total_weight
                self.weights[signal] *= 0.5  # Kalan aÄŸÄ±rlÄ±klarÄ± Adaptive_SuperTrend'e gÃ¶re normalize et


    def adaptive_supertrend(self, atr_period=10, factor=3, training_period=100):
        """ Adaptif SuperTrend sinyali """
        high = self.data['Max(TL)']
        low = self.data['Min(TL)']
        close = self.data['KapanÄ±ÅŸ(TL)']

        atr_indicator = AverageTrueRange(high=high, low=low, close=close, window=atr_period)
        atr = atr_indicator.average_true_range()

        volatility = atr.rolling(training_period).mean()
        volatility_array = volatility.dropna().values.reshape(-1, 1)

        kmeans = KMeans(n_clusters=3, random_state=42)
        kmeans.fit(volatility_array)

        sorted_centers = np.sort(kmeans.cluster_centers_, axis=0)
        low_volatility, medium_volatility, high_volatility = sorted_centers.ravel()

        hl2 = (high + low) / 2
        supertrend = pd.Series(index=close.index, dtype='float64')
        direction = pd.Series(index=close.index, dtype='int')

        for i in range(len(close)):
            if i < training_period:
                supertrend.iloc[i] = np.nan
                direction.iloc[i] = 0
                continue

            current_volatility = volatility.iloc[i]
            if current_volatility <= low_volatility:
                current_factor = factor * 0.5
            elif current_volatility <= medium_volatility:
                current_factor = factor
            else:
                current_factor = factor * 1.5

            upperband = hl2.iloc[i] + current_factor * atr.iloc[i]
            lowerband = hl2.iloc[i] - current_factor * atr.iloc[i]

            if i > 0:
                if supertrend.iloc[i - 1] <= upperband:
                    supertrend.iloc[i] = min(upperband, supertrend.iloc[i - 1])
                else:
                    supertrend.iloc[i] = max(lowerband, supertrend.iloc[i - 1])

                if close.iloc[i] > supertrend.iloc[i]:
                    direction.iloc[i] = 1
                elif close.iloc[i] < supertrend.iloc[i]:
                    direction.iloc[i] = -1
                else:
                    direction.iloc[i] = direction.iloc[i - 1]
            else:
                supertrend.iloc[i] = (upperband + lowerband) / 2
                direction.iloc[i] = 0

        return direction

    def ema_crossover(self, short_window, long_window):
        """ EMA crossover sinyali """
        short_ema = EMAIndicator(close=self.data['KapanÄ±ÅŸ(TL)'], window=short_window).ema_indicator()
        long_ema = EMAIndicator(close=self.data['KapanÄ±ÅŸ(TL)'], window=long_window).ema_indicator()
        signal = np.where(short_ema > long_ema, 1, -1)
        return pd.Series(signal, index=self.data.index)


    def macd_signal(self):
        """ MACD sinyali """
        macd = MACD(close=self.data['KapanÄ±ÅŸ(TL)'])
        macd_diff = macd.macd() - macd.macd_signal()
        signal = np.where(macd_diff > 0, 1, -1)
        return pd.Series(signal, index=self.data.index)

    def rsi_signal(self, window=14, overbought=65, oversold=35):
        """ RSI sinyali """
        rsi = RSIIndicator(close=self.data['KapanÄ±ÅŸ(TL)'], window=window).rsi()
        signal = np.where(rsi < oversold, 1, np.where(rsi > overbought, -1, 0))
        return pd.Series(signal, index=self.data.index)



    def bollinger_bands_signal(self, window=20, window_dev=2):
        """ Bollinger Band sinyali """
        indicator_bb = BollingerBands(close=self.data['KapanÄ±ÅŸ(TL)'], window=window, window_dev=window_dev)
        signal = np.where(self.data['KapanÄ±ÅŸ(TL)'] < indicator_bb.bollinger_lband(), 1,
                        np.where(self.data['KapanÄ±ÅŸ(TL)'] > indicator_bb.bollinger_hband(), -1, 0))
        return pd.Series(signal, index=self.data.index)


    def psar_signal(self, step=0.02, max_step=0.2):
        """ Parabolic SAR sinyali """
        psar = PSARIndicator(high=self.data['Max(TL)'], low=self.data['Min(TL)'], close=self.data['KapanÄ±ÅŸ(TL)'],
                            step=step, max_step=max_step)
        signal = np.where(self.data['KapanÄ±ÅŸ(TL)'] > psar.psar(), 1, -1)
        return pd.Series(signal, index=self.data.index)


    def nbar_signal(self):
        """ GeliÅŸtirilmiÅŸ NBAR sinyali """
        reversals_with_strength = self.nbar_detector.get_reversals_with_strength()
        signal = pd.Series(0, index=self.data.index)
        for reversal_type, index, pattern_type, strength in reversals_with_strength:
            if reversal_type == "Bullish":
                signal.iloc[index] = strength
            elif reversal_type == "Bearish":
                signal.iloc[index] = -strength
        return signal


    def order_blocks_signal(self):
        ob_signal = self.ob_detector.generate_ob_signal()
        
        
        # Sinyal deÄŸerlerini -1 ile 1 arasÄ±nda sÄ±nÄ±rla
        ob_signal = ob_signal.clip(-1, 1)
        
        return ob_signal


    def ichimoku_signal(self):
        """ Ichimoku sinyali """
        ichimoku = IchimokuIndicator(high=self.data['Max(TL)'], low=self.data['Min(TL)'])
        tenkan = ichimoku.ichimoku_conversion_line()
        kijun = ichimoku.ichimoku_base_line()
        signal = np.where(tenkan > kijun, 1, np.where(tenkan < kijun, -1, 0))
        return pd.Series(signal, index=self.data.index)


    def stochastic_signal(self, window=14, smooth_window=3):
        """ Stokastik osilatÃ¶r sinyali """
        stoch = StochasticOscillator(high=self.data['Max(TL)'], low=self.data['Min(TL)'], close=self.data['KapanÄ±ÅŸ(TL)'],
                                    window=window, smooth_window=smooth_window)
        signal = np.where(stoch.stoch_signal() > 80, -1, np.where(stoch.stoch_signal() < 20, 1, 0))
        return pd.Series(signal, index=self.data.index)


    def obv_signal(self):
        """ On Balance Volume (OBV) sinyali """
        obv = OnBalanceVolumeIndicator(close=self.data['KapanÄ±ÅŸ(TL)'], volume=self.data['Hacim(TL)'])
        obv_sma = obv.on_balance_volume().rolling(window=20).mean()
        signal = np.where(obv.on_balance_volume() > obv_sma, 1, -1)
        return pd.Series(signal, index=self.data.index)


    def support_resistance_signal(self, window=20):
        """ Destek ve direnÃ§ sinyali """
        pivot = (self.data['Max(TL)'] + self.data['Min(TL)'] + self.data['KapanÄ±ÅŸ(TL)']) / 3
        support = pivot - (self.data['Max(TL)'] - self.data['Min(TL)'])
        resistance = pivot + (self.data['Max(TL)'] - self.data['Min(TL)'])

        support_ma = support.rolling(window=window).mean()
        resistance_ma = resistance.rolling(window=window).mean()

        signal = np.where(self.data['KapanÄ±ÅŸ(TL)'] < support_ma, 1,
                        np.where(self.data['KapanÄ±ÅŸ(TL)'] > resistance_ma, -1, 0))
        return pd.Series(signal, index=self.data.index)


    def market_regime_signal(self, window=200):
        """ Piyasa rejimi sinyali """
        sma = EMAIndicator(close=self.data['KapanÄ±ÅŸ(TL)'], window=window).ema_indicator()
        volatility = self.data['KapanÄ±ÅŸ(TL)'].pct_change().rolling(window=window).std()

        trend = np.where(self.data['KapanÄ±ÅŸ(TL)'] > sma, 1, -1)
        regime = np.where(volatility > volatility.mean(), 0, trend)

        return pd.Series(regime, index=self.data.index)


    def get_signals(self, step):
        signals = {}
        for name, signal in self.signals.items():
            if isinstance(signal, pd.Series) and len(signal) > step:
                raw_signal = signal.iloc[step]
                # Sinyali -1 ile 1 arasÄ±nda sÄ±nÄ±rla
                normalized_signal = np.clip(raw_signal, -1, 1)
                weighted_signal = normalized_signal * self.weights[name]
                signals[name] = {"value": weighted_signal, "status": self.get_signal_status(weighted_signal)}
            else:
                print(f"Error: {name} signal is invalid or step exceeded.")
                signals[name] = {"value": 0, "status": "N/A"}

        # OrderBlocks iÃ§in ayrÄ± iÅŸlem yapalÄ±m
        self.ob_detector.update_order_blocks()
        ob_signal = self.order_blocks_signal().iloc[step]
        normalized_ob_signal = np.clip(ob_signal, -1, 1)
        signals['OrderBlocks'] = {"value": normalized_ob_signal * self.weights['OrderBlocks'], "status": self.get_signal_status(normalized_ob_signal)}

        return signals
    

    def get_signal_status(self, signal_value):
        abs_value = abs(signal_value)
        
        # Sinyal deÄŸerlerine gÃ¶re durumlarÄ± gÃ¼ncelle (AralÄ±klar geniÅŸletildi)
        if abs_value > 0.5:  # GÃ¼Ã§lÃ¼ Al/Sat iÃ§in aralÄ±ÄŸÄ± geniÅŸletelim
            return "ğŸŸ¢ Strong Buy" if signal_value > 0 else "ğŸ”´ Strong Sell"
        elif abs_value > 0.2:  # Al/Sat iÃ§in aralÄ±ÄŸÄ± geniÅŸletelim
            return "ğŸŸ¡ Buy" if signal_value > 0 else "ğŸŸ  Sell"
        elif abs_value > 0.05:  # NÃ¶tr ve zayÄ±f sinyaller iÃ§in daha ince aralÄ±klar
            return "âšª Weak Buy" if signal_value > 0 else "âšª Weak Sell"
        else:
            return "âšª Neutral"  # Tamamen nÃ¶tr sadece Ã§ok dÃ¼ÅŸÃ¼k deÄŸerlerde olmalÄ±




    def get_total_signal(self, step):
        signals = self.get_signals(step)
        
        # Extract only the 'value' from the signal dictionaries for summing
        signal_values = [data['value'] for data in signals.values()]

        # Now sum the signal values
        total_signal = sum(signal_values)

        # Print the total signal and its status
        print(f"\nğŸ”” Total Signal: {total_signal:.4f}")
        print(f"Overall Status: {self.get_signal_status(total_signal)}")
        
        return total_signal





    
    def print_signal_summary(self, signals, statuses):
        for name, value in signals.items():
            status = statuses[name]
            weight = self.weights[name]
    
    
    

    def print_weights_and_usage(self):
        """ Print the weights and usage counts """
        print("\nğŸ§® Indicator Weights and Usage Counts:")
        for signal in self.weights:
            print(f"{signal}: Weight = {self.weights[signal]:.4f}, Usage Count = {self.usage_count[signal]}")
        
        most_used = max(self.usage_count, key=self.usage_count.get)
        print(f"\nğŸ”¥ Most Used Indicator: {most_used} (Usage Count: {self.usage_count[most_used]})")

    def reward_summary(self):
        """ Print the reward history and current weights """
        print("\nğŸ… Reward History and Weights:")
        for signal in self.reward_history:
            avg_reward = np.mean(self.reward_history[signal]) if self.reward_history[signal] else 0
            print(f"{signal}: Average Reward = {avg_reward:.4f}, Current Weight = {self.weights[signal]:.4f}")

    def print_performance_summary(self):
        print("\nğŸ† Performance Summary:")
        for signal, score in sorted(self.performance_score.items(), key=lambda x: x[1], reverse=True):
            print(f"{signal}: Performance Score = {score:.4f}, Weight = {self.weights[signal]:.4f}")